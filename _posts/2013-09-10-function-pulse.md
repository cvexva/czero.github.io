---
layout: post
title: 脉冲式状态检测
categories: [javascript]
tags: [state check, trigger, timer, pulse]
---


#### 状态检测

在web编程时，我们经常要做的一件事就是__状态检测__。例如：

{% highlight javascript %}

    if(isWeekend){
        play();
    }else{
        work();
    }

{% endhighlight %}

在这里，`isWeekend`就是状态变量，我们需要通过检测这个状态变量来判断，接下来所需要完成的动作，在这里是`play()/work()`。

有了状态检测，接下来，我们需要面对的一件事，就是什么时候进行状态检测，这时我们就需要引入一个叫做_触发器_的概念。


#### 触发器

什么是触发器呢，说简单点就是触发状态检测的原因。

例如，当你点击某个按钮时，我们需要检测当前是否周末（`isWeekend`），然后弹出信息告诉我们到底是去玩还是去玩（哈哈！）。这样，_“点击按钮”_，就成为检测状态变量`isWeekend`的原因，也就是说是状态检测的触发器。

那么我们通常在编程时，会遇到的触发器有那些呢？`click`，`dbclick`，`mousedown`，`mouseenter`，`mouseover`，`mouseout`，`mouseleave`，`mousewheel`，`drag`，`swipe`，`tap`，`resize`，`focus`，`blur`，`change`，`timeout`，`interval`......（这里补充一点：由于我们讨论的是什么时候进行状态检测，这是一种异步的触发机制，所以我们讨论的触发器也是异步的触发器）。

当然除了上面这些，还有很多其他的触发器（例如ajax请求时的`readystatechange`等等）。


#### 时延问题

现在我们尝试讨论一下，触发器与代码实际执行之间的问题。下面是一个触发器（click事件）和与之对应的状态检测的时间流：

![click事件触发器][1]

可以看出来，由于浏览器的单线程和基于事件流的机制，触发器触发的时间与实际的状态检测时间总有一定的延时，而且这个延时并不是稳定的（如同种黄色的部分）。

这样的延时情况，对于只是检测当前是否周末这样的对时间精度要求不高的状态检测，其实不会产生任何实质上的影响。

然而对于某些特殊的状态检测，例如，在实现最近比较流行的滚蛋视差效果时，我们就需要检测页面当前的`scrollTop`状态，然后播放相应的动画帧，由于动画对时间精度要求是非常高的，这使得上面所说的那种延时现象就马上被放大得无法忍受了。

下面是触发器（mousewheel事件）与`scrollTop`检测的时间流：

![mousewheel事件触发器][2]

可以看出，即使mousewheel的触发时间相对均匀，但由于延时现象的原因，实际的状态检测却呈现出一片“混乱”，这就使得产生的动画会有种让人起鸡皮疙瘩的感觉，更何况mousewheel触发的时间本来就让人鸡皮疙瘩的。


#### 定时器

这时，我们伟大的工程师们，就想出了引入间接的触发器，也就是说，如果上面的触发器所指的是状态检测的直接原因，现在我们需要找一个状态检测的间接原因。

对于“动画”，最好的间接原因，当然就是时间了，时间一到，检测状态，播放对应的动画帧，一切妥妥的。

于是，我们就在程序里引入了定时器这个概念。其实定时器也是触发器的一种，只是，这个触发器的触发因素是时间，最好是一个稳定的时钟，在旧版的js中，`setInterval`就是很好的定时器（比`setTimeout`要稳定）。而在html5中，引入了一个新的，更加稳定的时钟————`requestAnimationFrame`（它的帧频为60fps）。

有了触发器，定时器，我们就可以完成那些对时间精度要求高的状态检测了。下图为添加了定时器的滚蛋视差状态检测时间流：

![定时器][3]

这样就可以完美的解决延时问题。（为了使动画运行更加流畅，在滚蛋视差程序里，需要添加一个间接状态变量`tweenTop`）。

但由于定时器只会根据时间来工作，即使没有工作要做，它也会死死的干活去，就如上图中那样，mousewheel本身并不是每时每刻的触发，`scrollTop`也不是每时每刻的都在变化，然而定时器却需要每时每刻的去检查它们的变化。

这是就带来一定的性能问题，特别是对于那些对时间精度有一定的要求，但实际的触发次数少或者说触发间隔又相对比较宽的情况。例如，在解决ie6，`position`为`fixed`无效的bug时，我们就可以通过引入定时器来检查`scrollTop`，然后设置元素的`top`来模拟`fixed`的效果。但毕竟这不是动画，每时每刻的去检查`scrollTop`来调整元素的位置，是非常的不划算，浪费，特别在ie6这种高龄老人身上，搞不好就进医院去了。


#### 脉冲检测

那有什么方法和解决这一的矛盾呢？暂时，我还没有找到（估计有，只是我没有找到而已）。

好，铺垫了这么久，终于来正题了，既然我没有找到别人的方法，那就只好自己想呗！而我想到的，就是脉冲式状态检测。

什么叫做脉冲式状态检测呢，其实就三句话:

1.  触发器触发产生时间脉冲
2.  时间脉冲内定时检测状态
3.  脉冲消失就停止检测状态

废话不多少，上图：

![脉冲检测][4]

从图中可看出，每次触发器触发都会引起一个小的时间脉冲，时间脉冲用于维护定时器的生命周期，而且由于时间脉冲能叠加，这样时间脉冲的总长度就只与，在很短时间内触发器第一次和最后一次触发之间的时间间隔有关（至于多短的时间，就要看单个时间脉冲的长度了）。

利用这样的方式，就能保证在时间脉冲内，定时的检测状态，保证时间的精度，然后时间脉冲一旦结束，状态的检测也会结束，这样就能使开销降低。

这个只是我的一个想法，至于如何实现，我下次再想。


[1]: {{ site.url }}/images/post/click-20140110-001.gif
[2]: {{ site.url }}/images/post/mousewheel-20140110-002.gif
[3]: {{ site.url }}/images/post/timer-20140110-003.gif
[4]: {{ site.url }}/images/post/pulse-20140110-004.gif